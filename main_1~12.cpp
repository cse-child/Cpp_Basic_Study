// 어소트락 게임 아카데미 - C/C++ 강의 12화 까지 정리문

// # : 전처리기, 소스코드가 실행될때 가장 먼저 실행된다.
// define: 내가 생성한 변수를 지정한 숫자로 치환해준다.
// define을 사용할 때 이점
// 1. 가독성
// 2. 유지보수
#define MAX_SIZE 20

// 비트로 상태를 표현하기 위한 상태변수 (32비트)
#define HUNGRY	0x001 // 0000 000'?'
#define THIRSTY 0x002 // 0000 00'?'0
#define TIRED	0x004 // 0000 0'?'00
#define FIRE	0x008

#define COLD	0x010 // 16의 16진수
#define POISON	0x020
#define POISON	0x040
#define POISON	0x080

#define POISON	0x100
#define POISON	0x200
#define POISON	0x400
#define POISON	0x800
// 실제 소스코드에서는 이런식으로 규칙적인 비트값이 입력되어 있다.


// 주석
// 설명 역할, 코드로 인식되지 않는다.

// 전역변수
int global = 0;

int Add(int left, int right) {
	return left + right;
}

int main() {

	// 자료형 (크기단위, byte) Data Type
	// 정수형 : char(1), short(2), int(4), long(4), long long(8)
	// 실수형 : float(4), double(8)

	// 1byte = 8bit (1bit = 0/1)
	// 1024byte = 1KB
	// 1024KB = 1MB
	// 1024MB = 1GB
	// 1024GB = 1TB
	// 1TB = 2^40 byte

	/* 정수형 자료형 */
	int i = 0;
	// 자료형: int
	// 변수명: i

	// 1 바이트로 양수만 표현
	// 256가지 -> 0 ~ 255
	unsigned char c = 0;
	c = 0;
	// c = 255;
	// -1은 8개의 비트가 모두 1로 채워진 형태이기 때문에 255로 볼 수 있다.
	// 따라서 unsigned 자료형이 양수형만 표현하지만 -1을 넣었을때도 문제로 인식하지 않을 수 있다.
	c = -1; 


	// 1 바이트로 양수, 음수 둘다 표현
	// -128 ~ 0 ~ 127
	char c1 = 0;
	// c1 = -1;
	c1 = 255; // 이것은 -1로 받아들여 진다.

	// 음의 정수 찾기 (2의 보수법)
	// 대응되는 양수의 부호를 반전 후, 1을 더한다.

	/* 실수형 자료형 */
	// 정수와 실수는 표현방식(체계)이 아예 다르기 때문에 둘을 혼합해서 사용하는것은
	// 의도하는 경우가 아닌 이상 피하는 것이 좋다.
	// 아래 수식은 4.0의 실수형이 4인 정수형으로 '형변환'되어 연산되는 과정이 숨겨져있다.
	int a = 4 + 4.0;

	// 실수의 비트 표현 방식 : 부동소수점 방식 (32bit = 부호비트(1), 지수비트(8), 가수비트(23))
	// 실수의 표현방식에서는 특정 실수에 딱 떨어지는 비트가 존재하지 못할수도 있기 때문에
	// 해당 실수에 가장 근사한 비트값을 구하게 된다.

	// 실수의 정확한 비트가 아닌 경우의 문제점
	// 그래서 예를들어 x == 1.f라는 조건문을 생성하면 0.999998f 라는 1에 근사치를 찾았음에도
	// 1로 딱 떨어지는 수치가 아니기때문에 조건문에 걸리지 않는 문제점이 발생하기도 한다.

	// --------------강의 정리----------------
	// 정수표현 방식과 실수표현 방식은 다르다.
	// 실수 표현방식은 정밀도에 의존한다.
	// 따라서 double(8) 자료형이 float(4) 보다 더 아래의 소수점까지 정확하게 표현 가능하다.

	// 정수는 정수끼리, 실수는 실수끼리 연산하되, 두 표현방식의 피 연산자가 연산될 경우 명시적으로 변환하자.

	// ex)
	float f = 10.2415f + (float)20; 
	// (float)을 적지 않아도 해당 연산은 일어나지만 명시적으로 표현한 것.


	/* 연산자 */
	// 대입 연산자: =

	// 산술 연산자
	// +, -, *, /, %(모듈러스, 나머지 연산, 피연산자가 모두 정수인 경우만 사용 가능)
	// ++, -- (증감 연산자)
	// 한 단계 증가 또는 감소
	int data = 10 + 10;
	// data = data + 20;
	data += 20;

	data = 10 % 3; // 1
	
	// data 변수의 자료형은 정수형(int)이기 때문에 연산결과 3.333..가 3으로 형변환 된다.
	data = 10. / 3.; 
	data = (int)(10. / 3.); 
	// 실수를 상수로 적을 경우 소수점 뒤에 f 를 붙이면 float 자료형으로, f 를 붙이지 않으면 double 자료형으로 판별한다.
	// 10.f / 10.

	
	data = 0;
	++data; // 전위(전치)
	data++; // 후위(후치) - 모든 연산자를 통틀어 가장 나중에 수행된다.
	// 연산자 우선순위가 가장 나중으로 열린다.

	a = 10;
	data = a++; // 10
	data = ++a; // 11
	// 웬만하면 전위 연산자를 사용하는 것이 좋다
	// 후위 연산자는 클래스나 구조체 오퍼레이터 함수로 호출되어 좋지않은 효율을 낼 수 있다.


	// 논리 연산자
	// !(역), &&(곱, And), ||(합, Or)
	// 참(true), 거짓(false)
	// 참: 0 이 아닌 값, 주로 1
	// 거짓: 0
	int truefalse = true; // 1
	int truefalse = false; // 0

	bool b = true; // 자료형을 굳이 따지자면 0,1로 떨어지니 정수형(1)
	// 근데 또 아예 정수형 자료형으로 사용할 순 없음
	bool IsTrue = 100; // 이라고 했을 때 isTrue는 1로 저장돼서 정수형으로 사용 불가

	IsTrue = true;
	IsTrue = !IsTrue; // false

	int iTrue = 100;
	iTrue = !iTrue; // 100을 1로 인식 후 뒤집어 0을 출력

	iTrue = 100 && 200; // 참 && 참 -> iTrue = 1
	iTrue = 0 && 200; // 거짓 && 참 -> iTrue = 0

	iTrue = 0 || 0; // iTrue = 0
	iTrue = 0 || 200; // iTrue = 1

	// 비교 연산자
	// ==, !=, <, <=, >, >=
	// 참, 거짓


	// 구문
	// if, else if, else
	data = 0;
	if (0 && 200) {
		data = 100;
	} 
	if (data == 100) {
		data = 200;
	}

	// switch - case
	switch (10) {
	case 10:
		break;
	case 20:
		break; // 깜빡하고 break를 작성하지 않으면 아래로 내려가 default까지 실행한다.
	case 30:
	case 40:
	case 50:
		// 30,40,50인경우의 공통적인 실행 구문이 있을 수 있으므로
		// case 아래에 break가 없는 것은 잘못된 문법 오류가 아니다.
		// if (iTest == 30 || iTest == 40 || iTest == 50) 인 경우와 동일하게 작동한다.
		break;
	
	default:
		break;
	}

	// 삼항 연산자
	// :?
	int iTest = 20;
	iTest == 20 ? iTest = 100 : iTest = 200;
	// 간략하게 작성할 수 있다는 장점이 존재하지만, 문맥을 한눈에 보기 힘들어서
	// 가독성이 떨어지는 단점이 있다. 따라서 정말 간략하게 문장을 쓰려는 의도가 아니라면 굳이 사용하지 않는다.

	// 비트 연산자 : 비트 단위로 진행되는 연산자
	// 쉬프트: <<, >>
	unsigned char byte = 1; // 0000 0001

	byte <<= 1; // 0000 0010 : 2왼쪽으로 비트가 한칸씩 밀림
	// 0000 1010: 10 -> 여기에 비트 연산자를 적용하면?
	// 0000 1010 << 1;
	// 0001 0100: 20
	// 결론: 왼쪽으로 쉬프트를 한번 하면 10진수 값이 2배가 된다.
	// 2칸 왼쪽으로 밀면 -> 2^2 = 4배 증가
	// 3칸 왼쪽으로 밀면 -> 2^3 = 8배 증가
	// 2^n 배수

	// 반대로 오른쪽 쉬프트를 사용한다면? >>
	// 1칸 오른쪽으로 밀면 10진수 값이 1/2 된다. -> 거짓
	byte = 10; // 0000 1010 : 10
	byte >>= 1; // 0000 0101 : 5
	byte >>= 1; // 0000 0010 : 2 -> 5를 2로 나눈 몫
	// 2^n 나눈 몫

	// 비트 곱(&), 합(|), xor(^), 반전(~)
	// 비트 단위로 연산을 진행
	// & : 둘다 1인 경우 1
	// | : 둘중 하나라도 1이면 1
	// ^ : 같으면 0, 다르면 1 - 기존에 알고있는 True, False 개념과는 반대되기 때문에 헷갈리기 쉽다.
	// ~ : 1은 0으로, 0은 1로
	// 비트 연산을 어디서 쓰지...........?
	// 아래와 같은 게임 속 캐릭터 상태를 나타낼 때 사용될 수 있음

	unsigned int iStatus = 0;

	iStatus |= HUNGRY; // 원래상태는 그대로 두고 HUNGRY의 비트만 1로 변경해줌. (원래 1이면 그대로 1)
	iStatus |= THIRSTY;

	// 내가 지정한 자리(0000 00'1'0)가 1인지 0인지 확인. 
	// 다른 자리는 뭐든 상관없음.
	// 상태 확인
	if (iStatus & THIRSTY) { 
		// 내 캐릭터가 지금 목마른 상태인가?
	}

	// 특정 자리 비트 제거
	iStatus &= ~THIRSTY; // 목마름 비트의 반전을 시켜서 상태를 바꿔준다.
	// iStatus  = 1110 1010
	// THIRSTY  = 0000 0010
	// ~THIRSTY = 1111 1101
	// 곱연산   = 1110 1000 : THIRSTY자리만 0으로 빼기
	// 해당 구문은 '암기'하는것이 좋다! -> 저 비트를 빼겠다는 코드구나~ 하고 바로 이해

	/* 변수 */
	// 1. 지역변수
	// 2. 전역변수
	// 3. 정적변수
	// 4. 외부변수

	// 지역변수
	int iName = 0;
	// 괄호 안에 선언된 변수(함수, 지역)
	{
		// 변수명 규칙
		int iName = 100;

		iName; // 괄호 안에서는 얘가 괄호밖에 있는 변수보다 우선순위 앞이다.
		
	}

	iName = 100; // 얘는 지역 밖에 있는 변수를 뜻함

	/* 함수 */
	data = Add(10, 20);



	return 0;
}