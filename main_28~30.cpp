// 어소트락 게임아카데미 - 28화. 포인터 배열부터

#include <stdlib.h>
#include <stdio.h>


void Test(int* a) {
	*a = 500;
	// 메인함수에 선언된 변수 값을 외부함수에서 변경하려면
	// 주소값에 지정된 영역으로 접근하여 변경해야 한다.
}


int main() {
	// 포인터 변수
	// 자료형 변수명
	int* pInt = nullptr;

	// 주소를 저장
	
	char* pChar = nullptr;
	short* pShort = nullptr;

	// 포인터의 크기는? 8 바이트 이다.
	// 내가 목적으로하는 운영체제에 따라 32bit 기반이면 4 Byte이고
	// 64bit 운영체제이면 8 Byte 이다.

	int iSize = sizeof(pInt);

	int i = 0;
	pInt = &i;
	// pInt의 주소가 100이라면 i는 int형(4Byte)이므로 
	// 101, 102, 103, 104번지에 저장됨
	// 따라서 pInt의 주소를 +1한다면 101번지가 아닌 104번지가 된다.
	
	// 강의 속 정리 : pInt는 int* 변수이기 때문에, 가리키는 곳을 int로 해석한다.
	// 따라서 주소값을 1 증가하는 의미는 다음 int 위치로 접근하기 위해서 sizeof(int) 단위로 증가하게 된다.

	// 포인터와 배열
	// 배열의 특징
	// 1. 메모리가 연속적인 구조이다.
	// 2. 배열의 이름은 배열의 시작 주소이다.
	int iArr[10] = {};

	// int 단위로 접근
	*(iArr + 0) = 10; // iArr[0] = 10;
	*(iArr + 1) = 10; // iArr[1] = 10;


	/*------ 포인터 이해 확인 문제 -----------*/
	// 문제 1.
	short sArr[10] = { 1,2,3,4,5,6,7,8,9,10 };

	int* pI = (int*)sArr;

	int iData = *((short*)(pI + 2));

	printf("1번 문제 정답 : %d\n", iData);
	// 풀이
	// short 배열은 2바이트씩 이루어져있다.
	// pI는 int형 포인터이기 때문에 4바이트 단위로 움직이게 된다.
	// pI에 +2를 했기 때문에 주소칸이 8바이트가 넘어가게 된다.

	// [1](2byte) - [2](2byte) - [3](2byte) - [4](2byte) - [5](2byte)

	//위와 같은 배열의 메모리 구조에서 8바이트가 넘어가면 5의 시작점에 포인터가 위치하게 된다.
	// 그러나 이때 (pI+2)를 접근하기 직전에 다시 (short*)포인터로 해석의 단위를 맞춰주었기 때문에
	// 2바이트만큼만 접근을 해서 [5]가 읽힌 것이다.
	// 만약 (short*) 포인터로 캐스팅을 하지 않았다면 (pI+2)는 int형이기 때문에
	// 4바이트를 읽어 ([5][6]) 의 두 숫자를 한번에 읽어 생각치못한 수가 등장하게 된다.
	

	// 문제 2.
	char cArr[2] = { 1,1 };

	short* pS = (short*)cArr;

	iData = *pS;

	printf("2번 문제 정답 : %d\n", iData);
	// 풀이
	// cArr은 char형 배열로 1바이트씩 이루어져 있다.
	// 그러나 short형 포인터는 2바이트 단위이기 때문에 cArr을 참조할때 2바이트씩 읽게된다.
	// 따라서 iData를 short형 포인터 pS로 바로 접근하게되면
	// {1, 1}을 하나의 숫자로 보게되고, 2바이트 정수로 보게 된다.
	// 즉 8비트(1)+8비트(1)의 메모리구조가 형성되어 256+1 = 257이 정답이 된다.
	/*---------------------------------------*/
	
	int a = 100;
	Test(&a);

	//scanf_s("%d", &a);


	/* const */
	const int cint = 100;
	// 상수화 : 숫자가 변하지 않음
	// l-value : 변수
	// r-value : 상수

	// const라는 키워드가 붙었다고 해서 일반적으로 사용하는 상수(10, 20, ..)처럼
	// 되는 것은 아니다. 문법적으로 상수화를 막아주는 것이지 진짜 상수는 아니다.



	return 0;
}