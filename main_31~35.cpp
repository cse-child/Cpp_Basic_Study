// 어소트락 게임아카데미 - 31화. const포인터 부터

#include <stdlib.h>
#include <stdio.h>


// 메모리 영역
// 1. 스택
// 2. 데이터
// 3. 힙
// 4. ROM(Read Only Memory, 읽기전용, 코드)


void Output(const int *pI) {
	int i = *pI;
	
	// 물론 const 포인터를 강제로 수정할수도 있긴 함.
	int * pInt = (int*)pI;
	*pInt = 1000;
}

int main() {

	// 1. const
	const int i = 100;

	// const 와 포인터
	int a = 0;
	int* pInt = &a;

	*pInt = 1;
	pInt = nullptr;
	// 포인터의 두가지 상황
	// 1. 포인터 자체가 가르킬 변수 주소가 변경되거나
	// 2. 포인터가 가르킨 변수의 값을 변경하거나

	// =============
	// const 포인터
	// =============
	int b = 0;
	const int* pConstInt = &a;
	// const 포인터는 "포인터가 가르키는 원본 변수가 상수화가 된 것"이다.

	// *pConstInt = 100;

	// 따라서 가르키는 변수의 값을 변경하진 못한다.

	pConstInt = &b;
	// 그러나 가르킬 변수는 변경할 수 있다.

	// =============
	// 포인터 const
	// =============
	int* const pIntConst = &a;
	*pIntConst = 400;
	// 포인터 const는 "포인터 변수 자체가 상수화가 된 것"이다.
	// 따라서 포인터가 가르키는 변수의 값은 변경할 수 있지만

	// pIntConst = &b;

	// 포인터가 가르킬 변수를 변경할 순 없다.

	// const와 포인터를 적절한 위치에 사용하면 두가지 모두 사용할수도 있다.
	// 초기화 시 가리킨 대상만 가리킴, 가리키는 원본을 수정할 수 없음
	const int* const pConstIntConst = nullptr;

	// 쉬운 암기법 !
	// const 위치 앞에 무엇이 있느냐?
	// const int* : const는 * '포인터'를 지칭하여 가르키는 변수를 상수화
	// const pIntConst : const는 pIntConst '변수'를 지칭하여 변수 자체가 상수화


	/* const 포인터를 사용하는 예시(경우) */
	a = 100;
	Output(&a);
	// 회사 내의 데이터가 너무 커서 데이터를 전달받진 못하고 
	// 데이터 저장 주소를 전달받는 경우 데이터를 변형시키지 않기 위해
	// 매개변수를 const 포인터로 받아야 한다.
	// 즉, 이 함수의 매개변수를 보면 "아~ 데이터 주소만 읽고 데이터를 바꾸진 않겠다는 거구나~" 라고 이해하면 됨
	// (단, 절대 못바꾸는 것은 아니고 바꿀 생각이 없다는 제작자의 의도를 보여주는 것)
	

	/* 33화. void 강의 */
	// void 포인터
	// 1. 원본의 자료형을 정하지 않는다.
	// 2. 어떠한 타입의 변수의 주소든 다 저장 가능
	// 3. 역참조 불가능
	// 4. 주소 연산 불가능
	void* pVoid = nullptr;
	
	{
		int a = 0;
		float f = 0.f;
		double d = 0.;
		long long ll = 0;

		pVoid = &a;
		pVoid = &f;
		pVoid = &d;
		pVoid = &ll;
		// void 포인터는 주소를 해석할 때 해석의 단위가 정해지지 않은 포인터이다.
		// 따라서 어떤 변수의 주소든지 모두 저장이 가능하다.

		// *pVoid;
		// 역참조가 불가능하며
		// pVoid + 1;
		// 주소 연산이 안된다.
	}

	// 포인터에서 가장 중요한 개념
	// 원본 데이터가 실제로 어떻게 사용되고 있는지는 포인터와 무관하다.
	// 포인터는 오로지 선언 시점때의 해당 포인터에 선언된 자료형 타입이 무엇인지에 따라 
	// 주소에 접근하는 방법과 분석 방법, 주소 연산 방법이 결정되는 것이다.
	// 따라서 어떠한 메모리 공간에 의미있는 데이터를 저장 시켰을 때에
	// 그 데이터대로 사용하려면 타입(자료형)에 정확히 매칭되도록 선언해야 한다.


	/* 34화. 문자 */
	wchar_t wc = 65; // 아스키코드 A
	short s = 49;

	// 메모리 상에서 상수 1과 문자로써 '1'은 다르다.
	char c = 1; // \x1
	c = '1'; // 아스키코드 49

	wc = 459; // 459를 숫자로 저장하면 459의 2진수 값이 저장된다.
	wc = '459'; // 그러나 459를 문자로 저장하면 '4'의 아스키코드 값과
	// '5', '9'의 아스키코드값이 각각 1바이트로 저장되어 총 3바이트에 저장된다.

	// char(1), wchar(2)
	char ch = 'a';
	wchar_t wct = L'a';

	char szChar[10] = "abcdef";
	wchar_t szWChar[10] = L"abcdef"; // 2바이트 문자(wchar)은 L 을 붙여야 한다.

	short arrShort[10] = { 97,98,99,100,101,102, };





	return 0;
}


// 단축키 : 함수 호출 원형
// Ctrl + Shift + Space